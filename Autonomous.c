#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     IRLeft,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     Compass,        sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     none,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     Conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    Gripper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    lock,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#define START_RED     "Red"
#define START_BLUE    "Blue"
#define START_INSIDE  "Inside"
#define START_OUTSIDE "Outside"
string startColor;
string startPosition;
int GoalPosition =0;//must be initialized as zero so it can overide when/if LocateInfaRedBeacon() produces no change
void getUserInput();
void initializeRobot();
task printf();
void Routine1();
void Routine2();
void Routine3();
void RoutineERR();
void locateInfaRedBeacon();
void Drive(int distance);
void Turn(int Angle);// +360 to -360
void Test();
task main()
{
//	Test();
	StartTask(printf);
	getUserInput();
	initializeRobot();
	waitForStart();
	locateInfaRedBeacon();//determins GoalPosition
	for(int Count=0; Count<3; Count++)
	{
		if(GoalPosition==1){
		Routine1();
		break;
		}
		else if(GoalPosition==2){
		Routine2();
		break;
		}
		else if(GoalPosition==3){
		Routine3();
		break;
		}
		else if(GoalPosition==0){
		RoutineERR();
		break;
		}
	}
	clearDebugStream();
}

void initializeRobot()
{
	servo[Gripper]=80;
}
void getUserInput()
{
  disableDiagnosticsDisplay();
  nxtDisplayCenteredTextLine(0, "Red or Blue?");
  nxtDisplayCenteredTextLine(7, "Red Blue");
  while(true)
  {
    if(nNxtButtonPressed == 2)
    {
      startColor = START_RED;
      nxtDisplayCenteredTextLine(0, "Red");
      break;
    }
    else if(nNxtButtonPressed == 1)
    {
      startColor = START_BLUE;
      nxtDisplayCenteredTextLine(0, "Blue");
      break;
    }
  }
  PlaySound(soundBlip);
  wait1Msec(1000);
  nxtDisplayCenteredTextLine(1, "Inside or Outside?");
  nxtDisplayCenteredTextLine(7, "Inside Outside");
  while(true)
  {
    if(nNxtButtonPressed == 2)
    {
      startPosition = START_INSIDE;
      nxtDisplayCenteredTextLine(1, "Inside");
      nxtDisplayCenteredTextLine(7, "");
      break;
    }
    else if(nNxtButtonPressed == 1)
    {
      startPosition = START_OUTSIDE;
      nxtDisplayCenteredTextLine(1, "Outside");
      nxtDisplayCenteredTextLine(7, "");
      break;
    }
  }
  PlaySound(soundFastUpwardTones);
  wait10Msec(200);
	enableDiagnosticsDisplay();
	nxtDisplayCenteredTextLine(0, "%s, %s",startColor, startPosition);
}
task printf()
{
	while(true)
	{
	clearDebugStream();
	writeDebugStreamLine("startPosition: %s", startPosition);
	writeDebugStreamLine("startColor:    %s", startColor);
	writeDebugStreamLine("GoalPosition: %i", GoalPosition);
	wait10Msec(100);
	clearDebugStream();
	}
}
void Routine1()
{

}
void Routine2()
{

}
void Routine3()
{

}
void RoutineERR()
{

}
void locateInfaRedBeacon()
{
//determine start Position(inside=floor, outside = ramp)
	if(startPosition == START_INSIDE)
	{
	//drive out of start Position and into GoalPosition_1
	Drive(50);
	Turn(90+45);//-360 to +360
	}
	else if(startPosition == START_OUTSIDE)
	{
	//drive out of start Position and into GoalPosition_1
	}

//check IR when robot has reached GoalPosition1
//if IR at GoalPosition 1 SET(int GoalPosition =1)and return 0;
//else drive out of GoalPosition1 and into GoalPosition_2
//check IR when robot has reached GoalPosition_2
//if IR at GoalPosition 2 SET(int GoalPosition =2)and return 0;
//else drive out of GoalPosition2 and into GoalPosition_3
//check IR when robot has reached GoalPosition_3
//if IR at GoalPosition 3 SET(int GoalPosition =1)and return 0;
	else
	{
	//drive to rolling goal
	}
}

void Drive(int distance)
{
	int C=2*(PI)*2;
	int Target= (1120/C)*distance;//en/in
	nMotorEncoder[motorE]=0;
	if(distance>1)
	{
		while(nMotorEncoder[motorE]<=Target)
		{
		writeDebugStreamLine("Value :%i, Target: %i",nMotorEncoder[motorE], Target);
		motor[motorD]=75;
		motor[motorE]=75;
		}
		motor[motorD]=0;
		motor[motorE]=0;
	}
	else if(distance<1)
	{
		while(nMotorEncoder[motorE]>=Target)
		{
		writeDebugStreamLine("Value :%i, Target: %i",nMotorEncoder[motorE], Target);
		motor[motorD]=-75;
		motor[motorE]=-75;
		}
		motor[motorD]=0;
		motor[motorE]=0;
	}
}
void Turn(int Angle)
{
	int Target= round(Angle*11.4;
	writeDebugStreamLine("Target:%i",Target);
  nMotorEncoder[motorE]=0;
  nMotorEncoder[motorD]=0;
  //1/2 rot= 45deg = 1120enc
	if(Angle<1)
	{
	//left
		while(nMotorEncoder[motorE]>= Target)
		{
		motor[Right]=100;
		motor[Left]=-100;
		}
		motor[Right]=0;
		motor[Left]=0;
	}
	else if(Angle>1)
	{
	//right
		while(nMotorEncoder[motorE]<= Target)
		{
		motor[Right]=-100;
		motor[Left]=100;
		}
		motor[Right]=0;
		motor[Left]=0;
	}
}
void Test()
{
//	Drive(10);
	Turn(90);
//  Drive(10);
//	Turn(-45);
}
